#### Наследяване

Наследяването позволява създаването на нови класове чрез използването на атрибути и поведение на съществуващи класове (новият клас има същите член-данни и методи на съществуващия клас). <br />
Класът, който наследяваме, наричаме основен, родителски, базов, или надклас.<br />
Класът, който наследява, наричаме производен, наследник, или подклас.<br />

``` 
                                           ----------------
                                           |Основен клас |
                                           ----------------
                                                   ^
                                                   |
                                                   |
                                           -------------------       
                                           | Производен клас |
                                           -------------------  
```
Синтаксис:
```
class <име> : [<видимост>] <базов клас>
              {, [<видимост>] <базов клас> }
{ <тяло на класа> };

<видимост> ::= private | protected | public
```
##### Спецификатори за достъп - преговор
Съществуват следните три спецификатора за достъп до компонентите на клас - public, private и protected.<br />
**Private компоненти** - те могат да се достъпват само в класа, в който са дефинирани и от приятелите на този клас. <br />
**Public компоненти** - те могат да се достъпват от всякъде.<br />
**Protected компоненти** - те могат да се достъпват както в класа, в който са дефинирани и неговите приятели, така и в класовете наследници и техните приятели.<br />
<br />
Опцията <видимост> (спецификатор за достъп) указва по какъв начин се наследяват член-данните и методите на базовия клас. Ако <видимост> липсва се подразбира  private.
- Ако <видимост>=public, означава че:
    - всички компоненти, които са public в базовия клас стават public в класа наследник;
    - всички компоненти, които са protected в базовия клас стават protected в класа наследник;
    - всички компоненти, които са private в базовия клас, класът наследник няма достъп до тях (но си съдържа!).
- Ако <видимост>=private, означава че:
    - всички компоненти, които са public в базовия клас стават private в класа наследник;
    - всички компоненти, които са protected в базовия клас стават private в класа наследник;
    - всички компоненти, които са private в базовия клас, класът наследник няма достъп до тях (но си съдържа!).
- Ако <видимост>=protected, означава че:
    - всички компоненти, които са public в базовия клас стават protected в класа наследник;
    - всички компоненти, които са protected в базовия клас стават protected в класа наследник;
    - всички компоненти, които са private в базовия клас, класът наследник няма достъп до тях (но си съдържа!).

Приятелството НЕ СЕ НАСЛЕДЯВА, тоест приятелите на базовия клас не са приятели на класа наследник.<br />
Един основен клас може да се наследи от няколко производни.<br />
В С++ е възможно един производен клас да има няколко основни. <br />

##### Предефиниране на наследени компоненти
Дефинирането на компоненти в производния клас, чието име съвпада с компонента на основния клас наричаме предефиниране (overriding). <br />
Често се използва за член-функции. <br />
Методът е същия по смисъл, но различен по реализация (Например: допълнителна реализация на наследения метод, или изцяло заместена реализация на наследнения метод). 
Пример:<br />
``` 
                                           ---------
                                           |Player |
                                           ---------
                                               ^
                                               |
                                               |
                                            --------      
                                            | Hero |
                                            --------
                                            
void Player::print() const{
    cout<<"Name: "<<name<<endl;
    cout<<"Points: "<<points<<endl;
}
void Hero::print() const{
    //Искаме да достъпим методът print() на базовия клас - Player, затова е нужно да се укаже пълното име (Player::print()), в противен случай се получава безкрайна рекурсия, защото се изпълнява безкрайно функцията print() на производния клас - Hero.
    Player::print();    
    cout<<"Level: "<<level<<endl;
}
```
##### Преобразуване на типове
Нека А е основен клас, а В наследява класа А (В - производен клас). <br />
Производния клас В се сита за подтип на основния клас А.<br />
Всеки обект от тип В може да се разглежда като от тип А.<br />
Някой обекти от тип А могат да се окаже от тип В.<br />
В е частен случай на А.<br />
В е разширение на А.<br />
В има повече информация от А.<br />
Обекти, указатели и псевдоними от В се преобразуват в обекти, указатели и псевдоними от В **неявно**.<br />
<br />
**От производен в основен** <br />
Пример: Нека разгледаме отново двата класа - Player, Hero.
```
Hero h; // h е обект от Hero
Hero* ph = &h; // ph е указател към обект от тип Hero. В случая указателят ph, сочи очекта h;
Hero& rh=h; // rh e псевдоним на обекта от тио Hero.
/*
                    h, rh
                    ----------------------------
             ph---> | Кетнис Евърдийн | 50 | 3 |
                    ----------------------------
*/
Player p=h; 
Player* pp=&h; pp=ph; pp=&rh;
Player& rp=h; rp=rh; rp=*ph;
// Обаче, чрез p, pp, rp могат да се достъпват само компонентите от класа Player.
```
**От основен в производен** <br />
Тази посока работи само чрез явно преобразуване, тъй като не винаги е коректна.
```
Player p;
Player* pp=&p;
Player& rp=p;
/*
                    p, rp
                    ----------------------
             pp---> | Гандалф Сивия | 45 |
                    ----------------------
*/
Hero h=(Hero const&)p;
Hero h; pp=&h; Hero* ph=(Hero*)pp;
Player& rp2=h; Hero& rh=(Hero&) rp2; Hero& rh2=(Hero&) rp;
```

