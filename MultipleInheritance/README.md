### Множествено наследяване

При множественото наследяване производнен клас има повече от един основен клас, например:
```
                                ---------     --------    ---------
                                | Base1 |     |Base2 |    | Base3 |
                                ---------     --------    ---------
                                      \         ^         /
                                       \        |        /
                                        \       |       /
                                         \      |      /
                                          \     |     /
                                           -----------       
                                           | Derived |
                                           -----------  
                                           
class Derived : public Base1, Base2, protected Base3 { ... };

```
Производния клас комбинира характеристиките и поведението на всичките си основни класове. <br />
Какво при единичното наследяване и тук важи правилото - всеки клас се грижи за собствените си член-данни.<br />
Ако за някои от класовете е пропуснат атрибут за област ( в примера за Base2), то се подразбира пак private.<br />

#### Конструктори и деструктори
Конструкторите на производния клас трябва да указват как се конструират всяка една от наследените  части.<br />
Ако за някой от основните класове не е указан кой конструтор да се извика, тогава се извиква този по подразбиране.<br />
Конструкторите, при създаване на обект от производния клас, се извикват в редът, в които са написани при наследяването : class Derived : public Base1, Base2, protected Base3 { ... };<br />
                                                     -------------------------------------------------><br />

##### Пример:
```
class Base1{                                            class Base2{
public:                                                 public:
    Base1(){                                                Base2(){
        cout<<"Base1::Constructor"<<endl;                       cout<<"Base2::Constructor"<<endl;
    }                                                       }
    ~Base1(){                                               ~Base2(){
        cout<<"Base1::Destructor"<<endl;                        cout<<"Base2::Destructor"<<endl;
    }                                                       }
    void doSmth() const{                                    void doSmth() const{
        cout<<"Base1::doSmth()"<<endl;                          cout<<"Base2::doSmth()"<<endl;
    }                                                       }
};                                                      };

class Derived : public Base1, private Base2{
public:
    Derived() : Base2(), Base1(){
        cout<<"Derived::Constructor"<<endl;
    }
    ~Derived(){
        cout<<"Derived::Destrutor"<<endl;
    }
};

int main () {
    Derived d;
    return 0;
}
```
Резултатът от изпълненито на програмата е следното:
```
Base1::Constructor
Base2::Constructor
Derived::Constructor
Derived::Destrutor
Base2::Destrutor
Base1::Destrutor
```
Виждаме че, конструкторите на освновните класове се извикват в реда на наследяването (въпреки че имаме Derived() : Base2(), Base1(), първо се извиква конструктора на Base1  и после се извиква конструктора на Base2), след което се извиква конструктора на производния клас.<br />
При деструкторите е обратно : извиква се деструктора на производния клас, а деструкторите на основните класове се извикват в ред обратен на преда на наследяване.<br />
<br />
Ако: 
```
int main () {
    Derived d;
    d.doSmth();
    return 0;
}
```
 Дава грешка, въпреки че нивата на достъп са различни. Трябва да направим следното: d.Base1::doSmth();. <br />

#### Проблем при множественото наследяване - Diamond problem
Нека имаме следното наследяване:
```
                                          -----
                                          | A |
                                          -----
                                         /     \
                                        /       \
        | част от А           |  имаме-----      -----       | част А              |
        |---------------------|  <--- | B |      | C | --->  |---------------------|
        | собствена част от B |       -----      -----       | собствена част от С |
                                        \        /
                                         \      / 
                                           -----
                                           | D |
                                           -----
                                             ↓ имаме
                                    -----------------------         
                                    |      част от А      | \
                                    -----------------------  В част
                                    | собствена част от В | /
                                    -----------------------
                                    |      част от А      | \
                                    -----------------------  C част
                                    | собствена част от С | /
                                    -----------------------
                                    | собствена част от D |
                                    -----------------------
```
Така за D се получават 2 копия на базовия клас А. Тогава от обект от D по какъв начин достъпваме компоненти наследени от A? И когата се опитваме да ги достъпим, за коя наледена компонента от А говорим - за това което се получава по пътя DBA или за това по пътя DCA?
Искаме да разрешим нееднозначността като поддържаме единствено копие на общия пра-основен клас.
Този проблем с двете инстанции на А се решава, като В и С наследят А като виртуален базов клас:
class B : ***virtual** public A { ... }; и class C : **virtual** public A { ... };

