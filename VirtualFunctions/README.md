#### Виртуални функции
Нека разгледаме следната йератьия от класове:
``` 
                                           ---------
                                           |Person |
                                           ---------
                                               ^
                                               |
                                               |
                                           -----------       
                                           | Student |
                                           -----------  
```
Нека и двата класа притежават член-функцията - void print() const, която извежда на екрана информацията съответно за Person и Student. Имплементациите на тази член-функция са:
```
void Person::print() const{
    cout<<"Name: "<<name<<endl;
    cout<<"Age: "<<age<<endl;
}

void Student::print() const{
    Person::print();
    cout<<"Faculty number: "<<facultyNumber<<endl;
}
```
Нека разгледаме следния код, и да видим какъв ще е изхода от него:
```
int main(){
    Student nina("Nina Petrova", 20, 81345);
    nina.print();
    cout<<"------------------------------\n";
    
    Student* ptr=&nina;
    ptr->print();
    cout<<"------------------------------\n";

    Student& ref=nina;
    ref.print();
    
    /* ptr е указател към обект от тип Student и сочи обекта nina (от тип Student).
       ref е псевдоним на обекта nina от тип Student.
    
                 nina, ref
                 -----------------------------
        ptr ---> | Nina Petrova | 20 | 81345 |
                 -----------------------------
        
    */
    
    return 0;
}
```
Резултата от изпълнението е:
```
Name: Nina Petrova
Age: 20
Faculty number: 81345
------------------------------
Name: Nina Petrova
Age: 20
Faculty number: 81345
------------------------------
Name: Nina Petrova
Age: 20
Faculty number: 81345
```
Горният резултат от програмата е ясен, тъй като и в трите случая функцията print е извикана от обекти, на които със съгурност знаем от кой тип са - Student (затова е ясно че се извиква Student::print()). <br />
<br />
Понеже Student е наследник на класа Person, можем да имаме указатели и референции от тип Person, към обекти от тип Student, което ни позволява да направим следното:
```
int main(){
    Student nina("Nina Petrova", 20, 81345);
    nina.print();
    cout<<"------------------------------\n";
    
    Person* ptr=&nina;
    ptr->print();
    cout<<"------------------------------\n";

    Person& ref=nina;
    ref.print();
    
    return 0;
}
```
Резултата от изпълнението е:
```
Name: Nina Petrova
Age: 20
Faculty number: 81345
------------------------------
Name: Nina Petrova
Age: 20
------------------------------
Name: Nina Petrova
Age: 20
```
В този случай, когато извикваме метода print() чрез указател и референция (към БАЗОВИЯ клас) от тип Person извиква се метода print() от класа Person, а не от класа Student.<br />
Обръщението към функцията print() през указател (референция) към БАЗОВИЯ клас Person се разрешава **статично по време на компилация**, т.е поглежда се от какъв тип е указателя - Person*, търси се функцията print в класа Person, и ако тя е в public частта на класа, значи може да се изпълни. < br />
Методът print(), който се извиква се определя по време на компилация и това се нарича static (early) binding.< br />
< br />
Нека добавим още един клас Teacher, който също наследява Person:
``` 
                                    ---------
                                    |Person |
                                    ---------
                                       ^ ^
                                      /   \
                                     /     \
                                    /       \
                          -----------       -----------
                          | Student |       | Teacher |
                          -----------       -----------
```
Като в класа Teacher, отново имаме метода print(), със следната имплементация:
```
void print() const{
    Person::print();
    cout<<"Teaching specialty: "<<specialty<<endl;
}
```
Нека имаме масив от указатели от тип Person, които да сочат към обекти от тип Student и Teacher. (това е **полиморфен масив** - масив с различни елементи)
```
    Student nina("Nina Petrova", 20, 81345);
    Techer docIvanov("doc. Ivanov", 56, "Linear algebra");
    
    Person* teachersAndStudents[2] = {&nina, &docIvanov};
    // teachersAndStidents е масив с 2 елемента, чиито елементи са указатели от тип Person, и понеже Student и Teacher са наследници на класа Person, може да имаме указатели от тип Person, към обекти от тип Student/Teacher.
```
Нека се опитаме да изведем даните за тях на стандартния изход:
```
    for(int i=0;i<2;i++){
        teacherAndStudents[i]->print();
    }
}
```
Както видяхме и по-горе това ще изведе само Person частта на обектите - име и години (teacherAndStudents[i] е указател към базовия клас Person, и методът print(), който се извиква се определя по време на компилация ). <br />
Този приблем, може да се опитаме да го решим, като при всяка итерация на цикъла проверяваме какъв е типът на обекта, към който сози указателя, и да преобразуваме указателя до този тип. Но това НЕ е удобно. <br />
<br />
Затова в C++, съществуват **виртуални функции**. <br />
**Динамично свърване** <br />
- Когато методът, който ще се извика, се определя по време на изпълнение, свързването се нарича динамично или късно (late binding);
- Извиква се методът на този клас, от който е обектът, към който сочи указателя ( а не от типа на указателя);
- Обектът може да е от базовия клас или от клас-наследник.

Можем да указваме какво е свързването за всяка отделна член-функция. Функция, за която свързването е динамично се нарича **виртуална**.
Това за горния пример декларираме функцията print() да бъде виртуална, по следния начин:
- В базовия клас : virtual void print() const;
- В класовете наследници: virtual void print() const override;

Виртуалната функция в базовия клас означава, че дава идея за това как да се случат нещата, обаче всеки от производните класове е свободен да направи промени.<br />
Тогава, горния пример (за извеждането на данните за учители и студенти) вече с виртуални фунцкии, извежда пълната информация за обектите, без да се налага да се преобразува типът на указателите. <br />
Класове с виртуални финкции се наричат **полиморфни**.

#### Особедности на виртуалните функции
- Само член-функциите могат да бъдат виртуални;
- Конструкторите не могат да са виртуални;
- Наследяващата член-функция в производния клас трябва да е със същата сигнатура;
- Наследяващите фунцкии са автоматично виртуални и virtual може да се пропусне;
- virtual се пише само пред декларацията, не пред дефиницията.
<br />

Виртуална функция в базовия клас означава **задължително** виртуален деструктор в базовия и производния клас !!!

#### Извикване на виртуални фунцкии
- Ако виртуалната функция бъде извикана чрез обект:
    - Person petya; petya.print(); -> СТАТИЧНО свързване - имаме обект, знаем от кой тип е обекта, така че това е print() на Person.
- Ако виртуалната фунцкия бъде извикана чрез указател:
    - Student nina(...); Person* prt=&nina; ptr->print(); -> ДИНАМИЧНО свързване.
- Ако виртуалната фунцкия бъде извикана чрез псевдоним:
    - Student nina(...); Person& ref=nina; ptr.print(); -> ДИНАМИЧНО свързване (еквивалентно на указател).
- Ако виртуалната фунцкия бъде извикана чрез указване на област:
    - Person::print(); -> СТАТИЧНО свързване, указали сме кой метод да се извика.
    
#### Механизъм на виртуалните таблици
По стандарт не е дефинирано как да се имплементират, но повечето компилатори използват така наречените виртуални таблици. Всеки обект освен член-данните си пази и указател към виртуална таблица за класа към който принадлежи. Виртуалните таблици пазят указатели, които сочат към кодовете на виртуалните функции. Когато се извиква някой виртуален метод чрез указател или референция към обект, с помощта на указателя към виртуалната таблица (който се пази в обекта) се поглежда във виртуалната таблица и от указателя към метода в нея се разбира къде се намира кода за съответния метод. Това ни позволява да имаме dynamic binding в C++. Ако някой метод не е пренаписан в класа наследник, тогава указателя във виртуална таблица за този метод ще сочи към кода на метода от базовия клас.

